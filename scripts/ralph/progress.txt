# Ralph Progress Log
Started: Sun Feb  1 00:05:22 EST 2026
---

## Codebase Patterns
- Aircraft data lives in `public/data/aircraft.json` — served as static asset, fetched at runtime via `loadAircraftCatalog()`
- `Aircraft.flightParams` is optional — when set, FlightSystem uses it instead of system-wide defaults
- `AircraftData.ts` has module-level state (`catalog`); tests must call `resetCatalog()` in `beforeEach`
- Use `npm run check` to run typecheck + tests together
- Babylon.js mocks in tests need `class` syntax (not arrow functions) for Vitest 4 constructors
- Use `await import("@babylonjs/core")` (not `require`) to access mocked modules in test assertions
- Port 5173+ may be occupied by other Vite apps; check output for actual port assigned
- Game class pattern: constructor takes canvas, initializes Engine → Scene → Camera → Light → meshes
- FlightInput interface decouples input from entities — Aircraft reads from FlightInput, not keyboard
- Mock Scene constructor needs cast: `new (Scene as unknown as new () => Scene)()` for typecheck
- Default GitHub PR base may not be `master` — always use `--base master` with `gh pr create`
- ECS-like pattern: entities hold state, systems operate on entities (FlightSystem updates Aircraft)
- `@babylonjs/gui` mocks also need class syntax for StackPanel, Slider, TextBlock (used with `new`)
- FlightSystem.params is mutable — DebugPanel sliders write directly to it for real-time tuning
- Use `vi.hoisted()` for mock functions referenced inside `vi.mock()` factories (hoisting issue)
- Skybox uses `infiniteDistance = true` so it always renders behind everything
- Terrain at 4000x4000 units is large enough for extended flight without reaching edges
- FlightInput interface now includes `fire: boolean` and `cycleTarget: boolean` — all mock inputs must include both
- ScreenShake tests need deterministic `Math.random` mock to avoid flaky magnitude comparisons
- `Ellipse` from `@babylonjs/gui` needs class-style mock (used by TargetingSystem reticle/lead marker)
- Projectile direction uses same math as FlightSystem: `sin(rotY)` for X, `cos(rotY)` for Z
- AIInput implements FlightInput with mutable fields — AISystem writes, Aircraft reads
- Aircraft constructor accepts optional name and color options for distinguishing enemy meshes
- `Math.atan2(dx, dz)` gives desired yaw toward a target in Babylon's coordinate system
- Normalize angle diff to [-PI, PI] with while loops for correct shortest-path turning
- Aircraft has `health` (number) and `alive` (boolean) — systems should check `alive` before operating
- CollisionSystem uses owner-pair pattern to prevent self-hits from own weapon system
- ParticleSystem mock needs class syntax with all fields (emitter, sizes, colors, etc.)
- `Rectangle` from `@babylonjs/gui` needs class-style mock (used by HitFlash in Game.test.ts)
- Camera shake: apply additive offset AFTER CameraSystem.update() positions the camera
- `Rectangle` with `cornerRadius` makes circular radar background; use `addControl` to nest blips inside
- Heading-up radar: rotate relative positions by `cos(heading)/sin(heading)` (positive heading, not negated)
- Adding a field to FlightInput requires updating mock input objects in ALL test files (Aircraft, Camera, Collision, Flight, Weapon, Targeting)
- `Ellipse.addControl` needed in GUI mocks when nesting TextBlock inside an Ellipse (lock indicator pattern)
- Edge-triggered fire for missiles: track `prevFire` to detect press vs hold
- Lock cone check: `Math.acos(dot / dist)` gives angle between player forward and target direction
- MissionLoader is a static factory: `MissionLoader.load(missionData, scene)` returns all spawned entities
- ObjectiveManager tracks kills via `recordKill()` and time via `update(dt)`, reports `outcome` as getter
- Mission JSON files live in `public/missions/` — fetched at runtime, not bundled as imports
- Mock `CreateCylinder` must return a NEW object per call (not spread of shared template) to avoid shared position refs
- HTML/CSS overlays (BriefingScene pattern): create div with `position:absolute;inset:0;z-index:100`, dispose removes from DOM
- Scene transition flow: main.ts fetches mission JSON → BriefingScene overlay → onLaunch callback disposes overlay and creates Game
- Game constructor takes `(canvas, MissionData, onMissionEnd)` — mission data drives ObjectiveManager and enemy spawns
- Game.dispose() stops render loop, disposes engine and InputManager — required for clean scene transitions
- Kill tracking: check `!enemy.alive` in render loop; use a counter to avoid double-counting
- Mission end: check ObjectiveManager.outcome + CollisionSystem.missionFailed each frame, fire callback once via `missionEnded` flag
- MissionResult interface lives in DebriefScene.ts — exported for Game.ts to use
- Game constructor signature: `(canvas, MissionData, onMissionEnd, aircraftId?)` — aircraftId applies per-aircraft stats
- Scene flow in main.ts: briefing → hangar → fly → debrief (hangar inserted between briefing and game)
- Node.js 22+ built-in `localStorage` lacks `getItem`/`setItem`/`clear` — SaveManager uses injectable `Storage` interface for testability
- SaveManager uses versioned key `topgun_save_v1` — bump version number for breaking schema changes
- ProgressionManager reads/writes via SaveManager — constructor loads state, mutations auto-save
- Theater-based aircraft unlocks: pacific → fa-18, middleeast → p-51
- Sequential mission unlock: completing `pacific-01` unlocks `pacific-02` (MISSION_ORDER array in ProgressionManager)
- FormationSystem manages wing/diamond formations; `FormationSpawn` in MissionData maps enemy indices to formation roles
- Formation engagement uses hysteresis: engage at 500 units, disengage at 800 units to prevent flapping
- Wingman offsets are rotated by leader heading for world-space positioning
- AISystem constructor takes optional `difficulty` (1-3); maneuver repertoire scales with difficulty
- `MissionData.aiDifficulty` configures AI difficulty per mission (defaults to 1)
- WeaponManager orchestrates all weapon types — wraps WeaponSystem (guns) and MissileLockSystem (heat-seeking)
- `cycleWeapon` (X key) cycles through weapon types: Guns → HeatSeeking → RadarGuided → Rockets → Bombs
- Adding a field to FlightInput requires updating type annotations AND mock objects in ALL test files
- Rocket entity: unguided, 350 speed, 3s lifetime, 35 damage — good for burst fire at ground targets
- Bomb entity: gravity-affected (30 units/s²), inherits aircraft forward velocity, 80 damage, detonates at ground level
- Missile `mode` param ("heat" | "radar"): heat=8s lifetime, radar=12s lifetime (fire-and-forget, longer range)
- `Hittable` interface in CollisionSystem: any entity with `mesh.position`, `alive`, `damage` can collide with aircraft
- `CollisionSystem.checkHittables()` handles rockets/bombs/missiles — separate from gun projectile checking
- WeaponLoadout extended: `radarMissiles?`, `rockets?`, `bombs?` (optional for backward compat)
- Game.ts uses `weaponManager` instead of separate `weaponSystem` + `missileLockSystem`
- HUD shows `WPN: <label>` and `AMMO: <count>` for the active weapon type

---

## 2026-02-01 - US-001
- What was implemented: Vite + TypeScript + Babylon.js project bootstrap with WASD-movable cube
- Files changed: package.json, tsconfig.json, vite.config.ts, index.html, .gitignore, src/main.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 7 new tests in src/Game.test.ts (3 scene setup + 4 movement)
- **Learnings for future iterations:**
  - Babylon.js uses `@babylonjs/core` modular imports (not monolithic `babylonjs`)
  - Vitest 4 requires class-based mocks for anything used with `new`
  - `Vector3.Zero()` is a static method — mocks need `Object.assign` or class statics
  - jsdom environment works for unit testing game logic but can't test WebGL rendering
---

## 2026-02-01 - US-002
- What was implemented: InputManager (keyboard → semantic axes) and Aircraft entity (cylinder mesh driven by FlightInput)
- Files changed: src/InputManager.ts, src/InputManager.test.ts, src/Aircraft.ts, src/Aircraft.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 18 new tests (12 InputManager + 6 Aircraft), Game tests updated to 5 (total 23)
- **Learnings for future iterations:**
  - FlightInput interface allows swapping input sources (keyboard, AI, network) without changing Aircraft
  - MeshBuilder.CreateCylinder with diameterTop=0 makes a cone shape (good aircraft placeholder)
  - GitHub default branch may differ from master — always specify `--base master` in `gh pr create`
  - Aircraft rotation.x = PI/2 points the cone forward (Babylon cylinders are Y-up by default)
---

## 2026-02-01 - US-003
- What was implemented: FlightSystem with velocity-based arcade movement, speed-dependent turning, stall/recovery, altitude floor, and DebugPanel with Babylon GUI sliders
- Files changed: src/FlightSystem.ts, src/FlightSystem.test.ts, src/DebugPanel.ts, src/DebugPanel.test.ts, src/Aircraft.ts, src/Aircraft.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 16 new tests (12 FlightSystem + 4 DebugPanel), Aircraft tests updated to 4, Game tests updated to 6 (total 38)
- **Learnings for future iterations:**
  - Aircraft.update() was removed — movement logic now lives in FlightSystem (ECS pattern)
  - Aircraft.input changed from `private` to `readonly` so systems can read it
  - Speed-dependent turn rate: `speedFactor = 1 - (speed/maxSpeed) * 0.7` gives a nice curve
  - Stall recovery: nose drops (rotation.x increases) and speed recovers automatically
  - DebugPanel uses AdvancedDynamicTexture.CreateFullscreenUI for screen-space GUI overlay
  - Babylon GUI Slider.onValueChangedObservable.add() for reactive parameter binding
  - CameraSystem uses lerp interpolation with configurable smoothing factor
  - Remove `camera.attachControl()` when using a custom CameraSystem to avoid input conflicts
---

## 2026-02-01 - US-004
- What was implemented: CameraSystem with smooth third-person chase camera, speed-dependent distance, and lerp interpolation
- Files changed: src/CameraSystem.ts, src/CameraSystem.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 6 new tests (5 CameraSystem + 1 Game), total now 44
- **Learnings for future iterations:**
  - FreeCamera.attachControl must be removed when CameraSystem manages positioning — otherwise built-in controls fight with custom logic
  - Lerp smoothing factor of 0.05 gives a nice smooth follow without feeling laggy
  - Speed-dependent distance formula: `baseDistance + (speed/maxSpeed) * speedDistanceScale`
  - Mock FreeCamera needs position as MockVector3 (with x/y/z), not a plain object
---

## 2026-02-01 - US-005
- What was implemented: Terrain class (4000x4000 textured ground plane) and Skybox class (large box with emissive gradient material, infinite distance)
- Files changed: src/Terrain.ts, src/Terrain.test.ts, src/Skybox.ts, src/Skybox.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 8 new tests (3 Terrain + 4 Skybox + 1 Game), total now 52
- **Learnings for future iterations:**
  - `vi.hoisted()` is required when mock functions need to be referenced inside `vi.mock()` factory (Vitest hoists `vi.mock` calls above variable declarations)
  - Babylon.js `infiniteDistance = true` makes skybox always render behind everything
  - `StandardMaterial.backFaceCulling = false` needed for skybox so inside faces are visible
  - `StandardMaterial.disableLighting = true` + `emissiveColor` gives a flat unlit sky color
  - 4000x4000 terrain with 32 subdivisions provides good coverage without perf issues
  - `(mock.calls[0] as unknown[])[1]` cast needed for TypeScript when accessing mock call args
---

## 2026-02-01 - US-006
- What was implemented: Projectile entity (tracer mesh, forward movement, lifetime expiry), WeaponSystem (spawns projectiles from aircraft nose, rate-of-fire cooldown), fire key (Space) added to InputManager/FlightInput
- Files changed: src/Projectile.ts, src/Projectile.test.ts, src/WeaponSystem.ts, src/WeaponSystem.test.ts, src/InputManager.ts, src/InputManager.test.ts, src/Game.ts, src/Game.test.ts, src/Aircraft.test.ts, src/CameraSystem.test.ts, src/FlightSystem.test.ts
- **Tests added:** 13 new tests (5 Projectile + 6 WeaponSystem + 1 InputManager fire + 1 Game), total now 65
- **Learnings for future iterations:**
  - Adding a field to FlightInput requires updating ALL mock input objects across test files
  - Projectile uses same direction math as FlightSystem for consistency
  - WeaponSystem cooldown of 0.15s gives a good rate of fire (~6.7 rounds/sec)
  - `as never` cast works for passing partial mock objects to typed system methods in tests
---

## 2026-02-01 - US-007
- What was implemented: AIInput (mutable FlightInput for AI), AISystem (pursuit/firing/evasion), enemy Aircraft with red color, enemy WeaponSystem, Game integration
- Files changed: src/AIInput.ts, src/AIInput.test.ts, src/AISystem.ts, src/AISystem.test.ts, src/Aircraft.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 12 new tests (8 AISystem + 2 AIInput + 2 Game), total now 77
- **Learnings for future iterations:**
  - Aircraft constructor now takes optional name and AircraftOptions (color) — backward compatible
  - AISystem.update takes `underFire` boolean — collision system will provide this in US-008
  - `Math.atan2(dx, dz)` gives desired yaw in Babylon's coordinate system (Z-forward)
  - Angle normalization to [-PI, PI] is critical for correct shortest-path steering
  - Enemy fires based on dot product angle check + distance — simple but effective
---

## 2026-02-01 - US-008
- What was implemented: CollisionSystem (bounding sphere projectile-aircraft collisions, damage, explosion VFX via ParticleSystem, ground collision detection, mission-failed state), Aircraft health/alive properties, FlightSystem skips dead aircraft, Game integration with owner-tracking to prevent self-hits, enemy underFire detection from nearby projectiles
- Files changed: src/CollisionSystem.ts, src/CollisionSystem.test.ts, src/Aircraft.ts, src/Aircraft.test.ts, src/FlightSystem.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 14 new tests (11 CollisionSystem + 2 Aircraft + 1 Game), total now 91
- **Learnings for future iterations:**
  - Owner-pair pattern: pass `{ aircraft, weaponSystem }` pairs to CollisionSystem to prevent self-hits
  - Babylon.js ParticleSystem with `targetStopDuration` + `disposeOnStop` creates self-cleaning burst effects
  - FlightSystem should check `aircraft.alive` before updating — dead aircraft shouldn't fly
  - Ground collision at altitude floor (y=2) means aircraft at terrain level are destroyed
  - `underFire` detection: check if any enemy projectile is within 100 units of the aircraft
---

## 2026-02-01 - US-009
- What was implemented: ScreenShake (decaying random camera offsets on damage), HitFlash (red GUI rectangle overlay that fades), CollisionSystem `playerHitThisFrame` flag, Game integration applying shake offsets to camera and triggering flash on player hits
- Files changed: src/ScreenShake.ts, src/ScreenShake.test.ts, src/HitFlash.ts, src/HitFlash.test.ts, src/CollisionSystem.ts, src/CollisionSystem.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 14 new tests (5 ScreenShake + 5 HitFlash + 2 CollisionSystem + 2 Game), total now 105
- **Learnings for future iterations:**
  - Exponential decay (`intensity *= Math.exp(-rate * dt)`) gives smooth, natural fade-out for screen effects
  - Camera shake is best applied as additive offset AFTER CameraSystem positions the camera
  - `Rectangle` from `@babylonjs/gui` needs class-style mock in Game.test.ts (like other GUI components)
  - `playerHitThisFrame` flag pattern keeps CollisionSystem decoupled from feedback systems
  - `isPointerBlocker = false` and `isHitTestVisible = false` on GUI overlays prevents them from eating input
- HUD uses `AdvancedDynamicTexture.CreateFullscreenUI` with a StackPanel for layout — same pattern as DebugPanel
- WeaponSystem has `ammo` field (default 200) — decrements on fire, stops firing at 0
---

## 2026-02-01 - US-010
- What was implemented: HUD class with speed, altitude, heading, ammo, and health text indicators using Babylon GUI; WeaponSystem ammo tracking (200 rounds, stops firing at 0); Game integration updating HUD each frame
- Files changed: src/Hud.ts, src/Hud.test.ts, src/WeaponSystem.ts, src/WeaponSystem.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 11 new tests (8 Hud + 2 WeaponSystem + 1 Game), total now 116
- **Learnings for future iterations:**
  - HUD StackPanel at bottom-left with `VERTICAL_ALIGNMENT_BOTTOM` keeps it out of gameplay view
  - Green text (#00ff88) on dark background is readable without being distracting
  - Heading normalization: convert radians to degrees, mod 360, add 360 if negative
  - WeaponSystem ammo field is public for HUD to read — pass ammo count to `hud.update()`
  - Multiple AdvancedDynamicTexture fullscreen UIs can coexist (DebugPanel, HitFlash, HUD)
---

## 2026-02-01 - US-011
- What was implemented: TargetingSystem with target reticle (Ellipse overlay), lead indicator for deflection shooting, Tab key cycle-target, distance readout; InputManager cycleTarget via Tab; AIInput cycleTarget field; fixed flaky ScreenShake tests with deterministic Math.random mock
- Files changed: src/TargetingSystem.ts, src/TargetingSystem.test.ts, src/InputManager.ts, src/InputManager.test.ts, src/AIInput.ts, src/Game.ts, src/Game.test.ts, src/ScreenShake.test.ts, src/Aircraft.test.ts, src/CameraSystem.test.ts, src/CollisionSystem.test.ts, src/FlightSystem.test.ts, src/WeaponSystem.test.ts
- **Tests added:** 10 new tests (8 TargetingSystem + 1 InputManager + 1 Game), total now 126
- **Learnings for future iterations:**
  - Adding a field to FlightInput requires updating ALL mock input objects across ALL test files
  - Lead indicator uses frame-to-frame position delta to estimate target velocity, then projects forward by distance/bulletSpeed
  - `Ellipse` from `@babylonjs/gui` is a good shape for reticle/lead marker overlays
  - `WeakMap` works well for per-entity state that auto-cleans when entities are garbage collected
  - ScreenShake tests were flaky due to Math.random — fixed by mocking with deterministic sequence
  - Screen-space projection: project world pos to camera plane using dot products with camera right/up/forward vectors
---

## 2026-02-01 - US-012
- What was implemented: Radar class — 2D top-down minimap in bottom-right corner showing enemy (red) and friendly (green) blips relative to centered player dot (white), with heading-up rotation and range scaling
- Files changed: src/Radar.ts, src/Radar.test.ts, src/Game.ts, src/Game.test.ts
- **Tests added:** 10 new tests (9 Radar + 1 Game), total now 136
- **Learnings for future iterations:**
  - `Rectangle` with `cornerRadius = size/2` creates a circular container for radar background
  - Heading-up rotation uses positive heading angle (not negated) with standard cos/sin rotation matrix
  - Blip pool pattern: grow pool lazily, hide excess blips — avoids creating/destroying GUI elements each frame
  - `rgba(0, 0, 0, 0.5)` background on Rectangle gives a nice semi-transparent radar overlay
  - Game.test.ts MockRectangle needed `cornerRadius`, `paddingRight`, `paddingTop`, `addControl` for Radar
---

## 2026-02-01 - US-013
- What was implemented: MissileLockSystem with state machine (Idle → Locking → Locked), Missile homing entity with limited turn rate, lock-on HUD indicator with progress %, R key for lock, missile ammo on HUD (MSL: 4), FlightInput lockOn field added
- Files changed: src/Missile.ts, src/Missile.test.ts, src/MissileLockSystem.ts, src/MissileLockSystem.test.ts, src/InputManager.ts, src/InputManager.test.ts, src/AIInput.ts, src/Hud.ts, src/Game.ts, src/Game.test.ts, + 6 test files updated for lockOn field
- **Tests added:** 18 new tests (6 Missile + 10 MissileLockSystem + 1 InputManager + 1 Game), total now 154
- **Learnings for future iterations:**
  - Adding a field to FlightInput requires updating ALL mock input objects across ALL test files — tedious but necessary
  - State machine pattern (enum + switch) is cleaner than boolean flags for multi-state systems like lock-on
  - Edge-triggered fire (`firePressed && !prevFire`) prevents continuous missile spam
  - Missile turn rate of 2.0 rad/s gives good gameplay — fast enough to track, slow enough to dodge
  - `Ellipse.addControl` must be in GUI mock when nesting TextBlock inside Ellipse
  - Lock cone of PI/6 (30°) half-angle feels right — not too generous, not too strict
---

## 2026-02-01 - US-014
- What was implemented: MissionData TypeScript interfaces, MissionLoader (static factory spawning player/enemies from JSON), ObjectiveManager (tracks destroy_enemies, destroy_all, survive_time objectives with success/failure outcome), example mission JSON (pacific-01)
- Files changed: src/MissionData.ts, src/MissionLoader.ts, src/MissionLoader.test.ts, src/ObjectiveManager.ts, src/ObjectiveManager.test.ts, public/missions/pacific-01.json
- **Tests added:** 16 new tests (10 ObjectiveManager + 6 MissionLoader), total now 170
- **Learnings for future iterations:**
  - MissionLoader.load() is a static factory returning MissionEntities — keeps it stateless and testable
  - ObjectiveManager uses a getter `outcome` that derives state from kills/time/failed — no manual state transitions
  - Mock objects with shared nested references (e.g., position) cause tests to interfere — always create fresh objects per mock call
  - Mission JSON in public/ directory means it's served as static assets by Vite, fetchable at runtime
---

## 2026-02-01 - US-015
- What was implemented: BriefingScene (HTML/CSS overlay showing mission title, description, theater, objectives, and Launch button), main.ts updated to fetch mission JSON and show briefing before starting Game
- Files changed: src/BriefingScene.ts, src/BriefingScene.test.ts, src/main.ts
- **Tests added:** 8 new tests in src/BriefingScene.test.ts, total now 178
- **Learnings for future iterations:**
  - HTML/CSS overlay approach is simpler than Babylon GUI for text-heavy UI screens (briefing, menus)
  - BriefingScene takes a container element + onLaunch callback — clean separation from game lifecycle
  - `dispose()` pattern with `this.overlay.remove()` ensures clean DOM teardown on scene transition
  - Many Vite dev servers may be running; check output for actual port assignment (can go up to 5189+)
---

## 2026-02-01 - US-016
- What was implemented: DebriefScene (HTML/CSS overlay showing kills, time, pass/fail, with Next Mission and Return to Menu buttons), Game integration with ObjectiveManager for kill tracking and mission end detection, Game.dispose() for clean teardown, main.ts full mission loop (briefing → fly → debrief → menu/next)
- Files changed: src/DebriefScene.ts, src/DebriefScene.test.ts, src/Game.ts, src/Game.test.ts, src/main.ts
- **Tests added:** 12 new tests (10 DebriefScene + 2 Game), total now 190
- **Learnings for future iterations:**
  - Game needs dispose() to clean up engine/input before transitioning scenes — otherwise render loop keeps running
  - Kill tracking via alive-flag check in render loop works but needs a counter to avoid double-counting
  - MissionResult interface exported from DebriefScene.ts — shared between Game and DebriefScene
  - main.ts orchestrates scene lifecycle via function calls (showBriefing, startMission, showDebrief) — no state machine needed yet
  - "Next Mission" and "Return to Menu" both go back to briefing for now — menu/campaign selection comes in later stories
---

## 2026-02-01 - US-017
- What was implemented: AircraftData module (types, catalog loader, registry), aircraft.json with 3 aircraft (F-14, P-51, F/A-18) with distinct stats, Aircraft.flightParams field, FlightSystem reads per-aircraft params
- Files changed: src/AircraftData.ts, src/AircraftData.test.ts, src/Aircraft.ts, src/FlightSystem.ts, src/FlightSystem.test.ts, public/data/aircraft.json
- **Tests added:** 10 new tests (8 AircraftData + 2 FlightSystem), total now 200
- **Learnings for future iterations:**
  - Module-level state in AircraftData needs `resetCatalog()` for test isolation
  - `aircraft.flightParams ?? this.params` pattern lets FlightSystem gracefully handle aircraft with or without custom params
  - Static JSON in `public/data/` is served by Vite and fetchable at runtime — same pattern as mission JSON
  - WeaponLoadout in aircraft data includes gunAmmo and missiles — ready for HangarScene to use
---

## 2026-02-01 - US-018
- What was implemented: HangarScene (HTML/CSS overlay displaying aircraft cards with stats, select buttons, locked aircraft support), Game accepts optional aircraftId to apply per-aircraft flight params and weapon loadout, main.ts flow updated to briefing → hangar → fly → debrief
- Files changed: src/HangarScene.ts, src/HangarScene.test.ts, src/Game.ts, src/main.ts
- **Tests added:** 7 new tests in src/HangarScene.test.ts, total now 207
- **Learnings for future iterations:**
  - HangarScene follows same HTML/CSS overlay pattern as BriefingScene — dispose() removes overlay from DOM
  - Game constructor takes optional `aircraftId` as 4th param — applies stats via `getAircraftStats()` after all systems are initialized
  - `data-aircraft-id` attribute on cards enables querying specific aircraft cards in tests
  - Locked aircraft: pass `lockedIds` array, cards render with LOCKED label and no Select button
  - Aircraft catalog must be loaded before showing HangarScene — `loadAircraftCatalog()` in start()
  - Border highlight on selection: set `borderColor` to `rgb(0, 170, 0)` (green) and reset others
---

## 2026-02-01 - US-019
- What was implemented: SaveManager (localStorage persistence with versioned keys, corruption handling), ProgressionManager (score calculation, mission completion tracking, sequential mission unlocking, theater-based aircraft unlocking), main.ts integration passing locked aircraft IDs to HangarScene and recording mission completions
- Files changed: src/SaveManager.ts, src/SaveManager.test.ts, src/ProgressionManager.ts, src/ProgressionManager.test.ts, src/main.ts
- **Tests added:** 19 new tests (5 SaveManager + 14 ProgressionManager), total now 226
- **Learnings for future iterations:**
  - Node.js 22+ has a built-in `localStorage` that lacks Web Storage API methods (`getItem`, `setItem`, `clear`) — need injectable Storage interface for tests
  - `vi.mock` doesn't help with Node's built-in localStorage proxy; mock storage objects are the clean solution
  - Score formula: kills * 500 + max(0, 1000 - time * 10) gives reasonable differentiation
  - MISSION_ORDER array defines sequential unlock — adding new missions requires updating this array
  - ProgressionManager auto-saves on every mutation via SaveManager.save()
---

## 2026-02-01 - US-020
- What was implemented: FormationSystem supporting wing pair and diamond formations with engagement/disengagement logic, FormationSpawn added to MissionData schema, Game integration with FormationSystem, pacific-01 updated with wing pair formation
- Files changed: src/FormationSystem.ts, src/FormationSystem.test.ts, src/Game.ts, src/Game.test.ts, src/MissionData.ts, public/missions/pacific-01.json
- **Tests added:** 10 new tests (9 FormationSystem + 1 Game) in src/FormationSystem.test.ts and src/Game.test.ts, total now 236
- **Learnings for future iterations:**
  - Hysteresis pattern (different engage/disengage thresholds) prevents formation state flapping
  - Wingman offset rotation: rotate local offsets by leader heading using cos/sin for world-space positioning
  - FormationSystem.updateAll() runs before AISystem — when disengaged, formation overrides wingman input; when engaged, AISystem takes over
  - `FormationSpawn.members` indices reference the `enemies` array in MissionData — first index is leader
---

## 2026-02-01 - US-021
- What was implemented: AISystem evasive maneuvers (break turn, barrel roll, split-S) with difficulty scaling (1-3), maneuver duration/continuation across frames, low-altitude split-S avoidance, `aiDifficulty` field in MissionData, Game passes difficulty to AISystem
- Files changed: src/AISystem.ts, src/AISystem.test.ts, src/MissionData.ts, src/Game.ts, public/missions/pacific-01.json
- **Tests added:** 8 new tests (7 evasive maneuvers + 1 difficulty config) in src/AISystem.test.ts, total now 244
- **Learnings for future iterations:**
  - Maneuver state machine: `activeManeuver` + `maneuverTimer` keeps the AI committed to a maneuver for its duration instead of re-rolling every frame
  - Split-S must be altitude-gated (MIN_SPLIT_S_ALTITUDE = 40) to prevent AI from diving into the ground
  - MANEUVERS_BY_DIFFICULTY lookup table cleanly maps difficulty levels to available maneuver repertoires
  - `maneuverDirection` (+1/-1) randomized at maneuver start gives variety without frame-to-frame randomness
  - Break turn uses yaw (not roll) for a hard heading change — distinct from barrel roll which uses roll
---

## 2026-02-01 - US-022
- What was implemented: Weapon variety — Rocket entity (unguided, burst fire), Bomb entity (gravity-affected), radar-guided missile mode on Missile, WeaponManager orchestrator with weapon cycling (X key), updated HUD with active weapon display, CollisionSystem.checkHittables() for new projectile types, WeaponLoadout extended with rockets/bombs/radarMissiles, aircraft.json updated with distinct loadouts per aircraft
- Files changed: src/Rocket.ts, src/Rocket.test.ts, src/Bomb.ts, src/Bomb.test.ts, src/WeaponManager.ts, src/WeaponManager.test.ts, src/Missile.ts, src/Missile.test.ts, src/Projectile.ts, src/CollisionSystem.ts, src/CollisionSystem.test.ts, src/InputManager.ts, src/InputManager.test.ts, src/AIInput.ts, src/AircraftData.ts, src/Hud.ts, src/Hud.test.ts, src/Game.ts, src/Game.test.ts, public/data/aircraft.json, + 5 test files updated for cycleWeapon field
- **Tests added:** 32 new tests (7 Rocket + 8 Bomb + 4 Missile radar + 9 WeaponManager + 3 HUD weapon + 1 InputManager), total now 276
- **Learnings for future iterations:**
  - WeaponManager wraps existing systems rather than replacing them — minimizes refactoring risk
  - Hittable interface allows CollisionSystem to handle any entity with mesh.position/alive/damage
  - Adding FlightInput fields is tedious — every mock input in every test file needs updating (consider a shared test helper)
  - Bomb inherits aircraft forward velocity at release for realistic parabolic trajectory
  - Radar missile is fire-and-forget — no continuous lock needed after launch (unlike heat-seeking)
  - HUD update signature changed from positional args to WeaponManager object — cleaner as weapon count grows
---
